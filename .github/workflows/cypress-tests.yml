name: Cypress E2E Tests

on:
  workflow_dispatch:
    inputs:
      suite:
        description: "Which tests to run (all or a specific suite)"
        required: true
        default: "all"
        type: choice
        options:
          - all
          - prompt-injections
          - out-of-scope
          - sql-manipulation
          - privilege-escalation
          - schema-hallucination
          - result-formatting
          - performance-stability
          - data-leakage
          - defensive-followups
      extraSpec:
        description: "Optional custom spec glob (overrides suite)"
        required: false
        default: ""
        type: string

jobs:
  cypress:
    name: Run Cypress
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
        working-directory: backend
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22

      - name: Create .env file from secrets
        env:
          DB_USER: ${{ secrets.DB_USER || vars.DB_USER || 'test_user' }}
          DB_PASS: ${{ secrets.DB_PASS || vars.DB_PASS || 'test_pass' }}
          DB_NAME: ${{ secrets.DB_NAME || vars.DB_NAME || 'test_db' }}
          JWT_ACCESS_SECRET: ${{ secrets.JWT_ACCESS_SECRET }}
          JWT_ACCESS_EXPIRATION: ${{ secrets.JWT_ACCESS_EXPIRATION || vars.JWT_ACCESS_EXPIRATION || '12h' }}
          LLM_BASE_URL: ${{ secrets.LLM_BASE_URL }}
          LLM_MODEL: ${{ secrets.LLM_MODEL }}
          LLM_API_KEY: ${{ secrets.LLM_API_KEY }}
        run: |
          cat > .env << EOF
          NODE_ENV=test
          DB_HOST=db
          DB_PORT=5432
          DB_USER=${DB_USER}
          DB_PASS=${DB_PASS}
          DB_NAME=${DB_NAME}
          DB_SYNC=false
          JWT_ACCESS_SECRET=${JWT_ACCESS_SECRET}
          JWT_ACCESS_EXPIRATION=${JWT_ACCESS_EXPIRATION}
          LLM_BASE_URL=${LLM_BASE_URL}
          LLM_MODEL=${LLM_MODEL}
          LLM_API_KEY=${LLM_API_KEY}
          DATABASE_URL=postgresql://${DB_USER}:${DB_PASS}@localhost:5432/${DB_NAME}
          EOF

      - name: Ensure clean node_modules
        run: |
          sudo rm -rf node_modules
          mkdir -p node_modules
          sudo chown -R "$USER":"$USER" node_modules

      - name: Install deps (npm ci)
        run: npm ci

      - name: Start services (docker compose up -d)
        run: |
          docker compose up -d

      - name: Wait for PostgreSQL to be ready
        env:
          DB_USER: ${{ secrets.DB_USER || vars.DB_USER || 'test_user' }}
        run: |
          echo "Waiting for Postgres to accept connections..."
          for i in {1..30}; do
            if docker exec customer-db pg_isready -U "$DB_USER" >/dev/null 2>&1; then
              echo "Postgres is ready."; break; fi; sleep 2;
          done

      - name: Wait for application to be ready
        run: |
          echo "Waiting for application to be ready on http://localhost:3000..."
          echo "Checking container status..."
          docker compose ps
          
          for i in {1..60}; do
            # First check if the app container is running
            if ! docker ps | grep -q customer-api; then
              echo "App container not running yet, waiting..."
              sleep 2
              continue
            fi
            
            # Check container health - see if it's actually running
            CONTAINER_STATUS=$(docker inspect customer-api --format='{{.State.Status}}' 2>/dev/null || echo "not found")
            echo "Container status: $CONTAINER_STATUS (attempt $i/60)"
            
            # If container exited, show logs and fail
            if [ "$CONTAINER_STATUS" = "exited" ]; then
              echo "Container has exited! Showing logs:"
              docker compose logs app --tail=100
              echo "Container exit code:"
              docker inspect customer-api --format='{{.State.ExitCode}}' 2>/dev/null || echo "unknown"
              exit 1
            fi
            
            # Check if the app is responding on the port
            if curl -f -s http://localhost:3000 >/dev/null 2>&1; then
              echo "Root endpoint responded! Checking /agent route..."
              # Check if the /agent route is accessible (this is what Cypress needs)
              if curl -f -s http://localhost:3000/agent >/dev/null 2>&1; then
                echo "Application /agent route is ready!"
                # Verify it's actually returning HTML content
                AGENT_CONTENT=$(curl -s http://localhost:3000/agent)
                if echo "$AGENT_CONTENT" | grep -q "Agent Streaming Demo"; then
                  echo "✓ Application is fully ready with expected content."
                  break
                else
                  echo "Agent route responded but content verification failed"
                fi
              else
                echo "Root works but /agent route not ready yet..."
              fi
            fi
            
            # Every 10 attempts, show progress and logs
            if [ $((i % 10)) -eq 0 ]; then
              echo "Still waiting... showing recent app logs:"
              docker compose logs app --tail=20
            fi
            
            if [ $i -eq 60 ]; then
              echo "❌ Application failed to start after 2 minutes"
              echo "Container status:"
              docker compose ps
              echo "App logs (last 100 lines):"
              docker compose logs app --tail=100
              echo "Testing connectivity:"
              curl -v http://localhost:3000/agent || true
              echo "Testing root:"
              curl -v http://localhost:3000 || true
              exit 1
            fi
            sleep 2
          done

      - name: Determine spec pattern
        id: spec
        run: |
          # Prioritize custom glob if provided
          if [[ -n "${{ github.event.inputs.extraSpec }}" ]]; then
            SPEC_GLOB="${{ github.event.inputs.extraSpec }}"
          else
            case "${{ github.event.inputs.suite }}" in
              all)
                SPEC_GLOB="cypress/e2e/**/*.cy.ts" ;;
              prompt-injections)
                SPEC_GLOB="cypress/e2e/agent-security/prompt-injections.cy.ts" ;;
              out-of-scope)
                SPEC_GLOB="cypress/e2e/agent-security/out-of-scope.cy.ts" ;;
              sql-manipulation)
                SPEC_GLOB="cypress/e2e/agent-security/sql-manipulation.cy.ts" ;;
              privilege-escalation)
                SPEC_GLOB="cypress/e2e/agent-security/privilege-escalation.cy.ts" ;;
              schema-hallucination)
                SPEC_GLOB="cypress/e2e/agent-security/schema-hallucination.cy.ts" ;;
              result-formatting)
                SPEC_GLOB="cypress/e2e/agent-security/result-formatting.cy.ts" ;;
              performance-stability)
                SPEC_GLOB="cypress/e2e/agent-security/performance-stability.cy.ts" ;;
              data-leakage)
                SPEC_GLOB="cypress/e2e/agent-security/data-leakage.cy.ts" ;;
              defensive-followups)
                SPEC_GLOB="cypress/e2e/agent-security/defensive-followups.cy.ts" ;;
              *)
                echo "Unknown suite '${{ github.event.inputs.suite }}', defaulting to all";
                SPEC_GLOB="cypress/e2e/**/*.cy.ts" ;;
            esac
          fi
          echo "spec_glob=$SPEC_GLOB" >> $GITHUB_OUTPUT

      - name: Verify application is accessible
        run: |
          echo "Final verification before running tests..."
          curl -f http://localhost:3000/agent >/dev/null 2>&1 || {
            echo "ERROR: /agent route is still not accessible!"
            docker compose logs app --tail=50
            exit 1
          }
          echo "✓ Application is ready for Cypress tests"

      - name: Run Cypress tests
        run: npm run test:cypress -- --spec "${{ steps.spec.outputs.spec_glob }}"

      - name: Generate Cypress Mochawesome report
        if: always()
        run: |
          mkdir -p cypress/reports || true
          # Clean up any existing merged file to avoid merge errors
          rm -f cypress/reports/mochawesome.json || true
          # Only merge if we have JSON report files
          if ls cypress/reports/*.json 1> /dev/null 2>&1; then
            npm run report:cypress || true
          else
            echo "No Cypress JSON reports found to merge"
          fi

      - name: Upload Cypress report artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: cypress-mochawesome-report
          path: backend/cypress/reports
          if-no-files-found: ignore

      - name: Compose status (always)
        if: always()
        run: |
          docker compose ps || true
          docker compose logs db --tail=200 || true
          docker compose logs app --tail=200 || true

      - name: Tear down (docker compose down)
        if: always()
        run: |
          docker compose down -v


